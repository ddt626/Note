# 存取層級
- 存取層級
  - private
    - 存取只限於包含的類別 
  - protected
    - 存取只限於包含的類別或衍生自包含類別的型別 
  - internal
    - 存取只限於目前的組件 
  - protected internal
    - 存取只限於目前的組件或衍生自包含類別的型別 
  - public
    - 存取沒有限制 
- 規則  
  - 存取修飾詞不能用於命名空間，因此命名空間沒有存取限制 
  - 命名空間中的最上層型別只能有 internal 或 public 存取範圍，這些型別的預設存取範圍是 internal    
  
- 善用存取層級實現封裝
  
# 靜態類別和靜態成員
- 靜態類別
  - 只包含靜態成員
  - 沒有執行個體的建構函式
  - 無法產生實體
  - 沒辦法被繼承
  - 基底類別只能是 Object Type

- 靜態建構函式
  - 一般來說很少用，通常用來當類別使用記錄檔，而建構函式被用來將項相寫入檔案
  - 用來初始化任何靜態資料或執行只需執行一次的特定動作。
  - 當這個類別被使用時或是參考任何靜態成員時會呼叫靜態建構函式，
    而且只會呼叫第一次
  - 靜態建構函式並不使用存取修飾詞，也沒有參數
  - 不能直接呼叫靜態建構函式
  - 沒有多載，因為不能呼叫
  - 使用者無法控制程式中靜態建構函式執行的時間
  - 如果在靜態建構函式丟出例外，執行階段將不會再一次叫用它，
    而且型別都將保持未初始化狀態
  
- 靜態成員
  - 除非透過執行個體，否則靜態成員無法直接存取執行個體成員
  - 靜態方法可以多載但不能覆寫
  - 不支援靜態區域變數
  - this 沒有用
  - 靜態方法與執行個體方法的選擇
    - 執行個體方法通常是跟自已有關系

# 擴充方法
  - 擴充方法
    - 可以將方法加入至現有類型，而不需要建立新的衍生類型(Derived Type)、重新編譯或修改原始類型
    - 是一種特殊的靜態方法，但是需要將它們當成擴充類型上的執行個體方法(Instance Method)來呼叫
    - 讓靜態方法看起來像執行個體方法
    - 執行個體方法會比靜態方法方便閱讀

# 介面
- 概觀
  - 介面是一系列方法、屬性、事件與索引的簽章
  - 介面不能定義執行個體欄位與建構式
  - 不允許在介面中定義靜態成員
  - 可視為一種契約
  - 介面的設計要儘量簡單

- 明確實作介面
  - 避免同名的情況
    - 出現相同簽章成員時
  - 必須在變數型別為此介面型別時才能呼叫
  - 通常只會在內部呼叫
  
- 參數簽章不同可以同時實作，簽章相同回傳不同需明確實作
  
# 泛型

- 概觀
  - 2.0之後才出現 
  - 不等於 泛型參數
  - 泛型是強型別的概念，由 caller 決定型別
  - 避免容器操作的 Boxing 與 Unboxing

- 應用面
  - 泛型介面
    - interface Itest<T>
  - 泛型類別
    - class Tset<T>
  - 泛型方法
    - void Test<T> (T value)
    - T Test<T>()
  - 泛型委派
    - delegate void Del<T> (T item)

- default 關鍵字
  - 只會回傳 0 或是 null
  - 通常在沒有條件約束時使用
  - 泛型時不能return null，要使用 default(T)

- 泛型條件約束
  - 可限制用戶端程式碼在執行個體化類別時的型別 
  - 使用 where 指定條件約束
  - where T : struct
    - 型別引數必須是實值型別
  - where T : class
    - 型別引數必須是參考型別
  - where T : new()
    - 型別引數必須擁有公用的無參數建構函式
    - 與其它條件約束一起使用時，要指定其為最後一個
  - where T : <base class name>
    - 型別引數必須本身是指定的基底類別，或衍生自該類別
  - where T : <interface name>
    - 型別引數必須本身是指定的介面或實作該介面
  - where T : U
    - 提供給 T 的型別引數必須是提供給 U 的引數 

# 不變性、共變性、逆變性

- 不變性 Invariant
  - 當你用什麼的時候就是什麼，沒有辦法改變

  - 泛型的類別是 不變性 
    - 不能直接轉換 `List<string> -> List<object>`
  
- 共變性 和 逆變性 合稱 變異性

- 共變性 Convariant
  - 用基底類別取代延伸類別
  - 用大的型別取代小的型別

- 逆變性 Contravariant
  - 用衍生類別取代基底類別 
  - 用小的型別取代大的型別 

- 共變用在 輸出 (等號左邊)，逆變用在 輸入(等號右邊)

- 型別安全
  - 編輯時就可以檢查形別是錯的
  - 為了型別安全，不要隨便用 `object`
  - 多型 -> 變異性 -> 型別安全
  
# 泛型介面變異性
- 宣告
  - <out T> 共變性
  - <In T> 逆變性
  
- 有共變性的即有泛型介面
  - IEnumerable<T>
  - IEnumerator<T>
  - IQueryable<T>
  - IGrouping<TKey, TElement>
  - 都是在等號的左邊
  - `IEnumerable<string> x = List<string>`

- 有逆變性的即有泛型介面
  - IComparer<T>
  - IComparable<T>
  - IEqualityComparer<T>
  
- 泛型與多載的選擇
  - IComparable<T>
    - 不需要 Boxing  
    - `int CompareTo(T other)`

- 變異性與委派
  - 委派的回傳型別支援共變性
  - 委派的參數型別支援逆變性
  - 事件支援逆變
    - 沒有規定簽章一定要一模一樣，應該說是相似就可以

# 索引子

- 使用與陣列相同的方式來索引類別或結構的執行個體
- this 的關鍵字的用途為定義索引子
- 不一定要使用整數值來索引，可以自已決定如何定義特定的查詢機制
- 可以多載
- 可以具有一個以上的型式參數，例如二維陣列
- 介面中也可以宣告

# 類別設計

- 概觀
  - 流程 
    - 需求 -> 職責 -> 抽象
  - 目標 
    - 高內聚 低耦合
  - 職責有沒有必要細分，有沒有必要組合
  - 相關的東西要在一起 - 高內聚
  - 繼承會破壞高內聚
  - 找出職責的狀況
  - 兩個不相關的東西不要在一起 - 低耦合
    - 強相依，低相依
    - 要相依於抽象

- 技巧
  - 寫了一段程式，為什麼要這樣子設計
  - 所有的設計都跟你的情境有關系，只要講的出道理就是對的
  - 如果假設過了頭，就會過度設計，如果假設不足，就會出錯
  - 想像力很重要
    - 所以需要畫圖
  - 進化的重構 
    - 寫程式的時候要回頭看自已寫過的
      - 是否有重複的程式
      - 消滅分支
        - switch case 

- 類別與介面的選擇
  - 抽象類別著重在於重用
  - 介面著重的是抽象程度
  - 重用 -> 彈性 / 血統 -> 能力
