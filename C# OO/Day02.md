# 存取層級
  - private 
  - protected
  - internal
  - protected internal
  - public
  - 規則  
    - 命名空間沒有存取限制    
    
- 用存取層級實現封裝
  
- 靜態類別
  - 沒有執行個體的建構式
  - 沒辦法被繼承

- 靜態建構函式
 - 一般來說很少寫
 - 沒有多載，因為不能呼叫
 - 當這個類別被使用時，會呼叫這個建構式，只會呼叫第一次
 - 參考任何靜態成員時，會呼叫

- 靜態成員
  - this 沒有用
  - 靜態方法與執行個體方法的選擇
    - 執行個體方法通常是跟自已有關系

- 擴充方法
  - 讓靜態方法看起來像執行個體方法
  - 執行個體方法會比靜態方法方便閱讀
  - 執行個體方法和靜態方法同名時

# 介面

- 明確實作
  - 避免同名的情況
  - 通常只會在內部呼叫
  
- 參數簽章不同可以同時實作，簽章相同回傳不同需明確實作
  
# 泛型

- 概觀
  - <> 泛型參數
  - 由caller 決定型別

- 應用面
  
- default
  - 只會回傳 0 或是 null
  - 泛型時不能return null，要使用 default(T)

- 泛型條件約束
  - 一定要有無參數的建構式 `: new()`

# 不變性、共變性、逆變性

- 不變性
  - 當你用什麼的時候就是什麼，沒有辦法改變

- 泛型的類別是 不變性
  - 不能直接轉換 `List<string> -> List<object>`
  
- 共變性 和 逆變性 合稱 變異性

- 共變性
  - 用基底型別取代延伸型別
  - 用大的型別取代小的型別

- 逆變性
  - 用小的型別取代大的型別 

- 共變用在 輸出 (等號左邊)，逆變用在 輸入(等號右邊)

- 型別安全
  - 編輯時就可以檢查形別是錯的
  - 為了型別安全，不要隨便用 `object`
  - 多型 -> 變異性 -> 型別安全
  
- 泛型介面變異性
  - <out T> 共變性
  - <In T> 逆變性
  
- 有共變性的即有泛型介面
  - 在等號的左邊
  - `IEnumerable<string> x = List<string>`

- 有逆變性的
  - IComparer
  
- 泛型與多載的選擇
  - IComparable<T>
    - 不需要 Boxing  
    - `int CompareTo(T other)`
  
- 事件支援 逆變，沒有說簽章一定要一樣，應該說是相似

- 索引子

# 類別設計

- 概觀
  - 流程 - 需求 -> 職責 -> 抽象
  - 目標 - 高內聚 低耦合
  - 職責有沒有必要細分，有沒有必要組合
  - 相關的東西要在一起 - 高內聚
  - 繼承會破壞高內聚
  - 找出職責的狀況
  - 兩個不相關的東西不要在一起 - 低耦合
    - 強相依，低相依
    - 要相依於抽象
  - 成績計算系統
    - 資料庫 
      - query
      - insert
      - update
      - deete
    - 成績計算
      - 平均成績
      - 各科成績
      - 總成績
      - 排名

- 技巧
  - 寫了一段程式，為什麼要這樣子設計
  - 所有的設計都跟你的情境有關系
  - 所有的設計只要講的出來道理就是對的
  - 如果假設過了頭，就會過度設計，如果假設不足，就會出錯
  - 想像力很重要
    - 所以要畫圖
  - 進化的重構 - 寫程式的時候要回頭看自已寫過的
    - 重複的程式
    - switch case - 消滅分支

- 類別與介面的選擇
  - 抽象類別著重在於重用
  - 介面著重的是抽象程度
  - 重用 -> 彈性 / 血統 -> 能力
