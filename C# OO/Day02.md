# 存取層級
  - private 
  - protected
  - internal
  - protected internal
  - public
  - 規則  
    - 命名空間沒有存取限制    
    
- 用存取層級實現封裝
  
- 靜態類別
  - 沒有執行個體的建構式
  - 沒辦法被繼承

- 靜態建構函式
 - 一般來說很少寫
 - 沒有多載，因為不能呼叫
 - 當這個類別被使用時，會呼叫這個建構式，只會呼叫第一次
 - 參考任何靜態成員時，會呼叫

- 靜態成員
  - this 沒有用
  - 靜態方法與執行個體方法的選擇
    - 執行個體方法通常是跟自已有關系

- 擴充方法
  - 讓靜態方法看起來像執行個體方法
  - 執行個體方法會比靜態方法方便閱讀
  - 執行個體方法和靜態方法同名時

# 介面

- 明確實作
  - 避免同名的情況
  - 通常只會在內部呼叫
  
- 參數簽章不同可以同時實作，簽章相同回傳不同需明確實作
  
# 泛型

- 概觀
  - <> 泛型參數
  - 由caller 決定型別

- 應用面
  
- default
  - 只會回傳 0 或是 null
  - 泛型時不能return null，要使用 default(T)

- 泛型條件約束
  - 一定要有無參數的建構式 `: new()`

# 不變性、共變性、逆變性

- 不變性
  - 當你用什麼的時候就是什麼，沒有辦法改變

- 泛型的類別是 不變性
  - 不能直接轉換 `List<string> -> List<object>`
  
- 共變性 和 逆變性 合稱 變異性

- 共變性
  - 用基底型別取代延伸型別
  - 用大的型別取代小的型別

- 逆變性
  - 用小的型別取代大的型別 

- 共變用在 輸出 (等號左邊)，逆變用在 輸入(等號右邊)

- 型別安全
  - 編輯時就可以檢查形別是錯的
  - 為了型別安全，不要隨便用 `object`
  - 多型 -> 變異性 -> 型別安全
  
- 泛型介面變異性
  - <out T> 共變性
  - <In T> 逆變性
  
- 有共變性的即有泛型介面
  - 在等號的左邊
  - `IEnumerable<string> x = List<string>`

- 有逆變性的
  - IComparer
  
- 泛型與多載的選擇
  - IComparable<T>
    - 不需要 Boxing  
    - `int CompareTo(T other)`
  
